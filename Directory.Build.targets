<Project>
  <PropertyGroup>
    <!-- Assumes building projects in this repo (not submodules). i.e: src/Sentry.Unity -->
    <UnitySampleProjectPath>$(MSBuildProjectDirectory)/../../samples/unity-of-bugs/</UnitySampleProjectPath>
    <PlayerBuildPath>$(UnitySampleProjectPath)../artifacts/builds/</PlayerBuildPath>
    <AndroidBuildMethod>Builder.BuildAndroidIl2CPPPlayer</AndroidBuildMethod>
    <AndroidBuildPath>$(PlayerBuildPath)Android/IL2CPP_Player.apk</AndroidBuildPath>
    <IOSBuildMethod>Builder.BuildIOSPlayer</IOSBuildMethod>
    <IOSBuildPath>$(PlayerBuildPath)iOS/Xcode</IOSBuildPath>
    <!-- Assumes running `dotnet` from the root of the repo: -->
    <UnityTestPlayModeResultFilePath>../../artifacts/test/playmode/results.xml</UnityTestPlayModeResultFilePath>
    <UnityTestEditModeResultFilePath>../../artifacts/test/editmode/results.xml</UnityTestEditModeResultFilePath>
    <SentryArtifactsDestination>$(RepoRoot)package-dev/Plugins/</SentryArtifactsDestination>
    <!-- Cocoa -->
    <SentryCocoaRoot>$(RepoRoot)modules/sentry-cocoa/</SentryCocoaRoot>
    <SentryiOSArtifactsDestination>$(SentryArtifactsDestination)iOS/Sentry.xcframework~/</SentryiOSArtifactsDestination>
    <SentrymacOSArtifactsDestination>$(SentryArtifactsDestination)macOS/Sentry/</SentrymacOSArtifactsDestination>
    <!-- Android -->
    <SentryAndroidRoot>$(RepoRoot)modules/sentry-java/</SentryAndroidRoot>
    <SentryAndroidArtifactsDestination>$(SentryArtifactsDestination)Android/Sentry/</SentryAndroidArtifactsDestination>
    <!-- Native -->
    <SentryNativeRoot>$(RepoRoot)modules/sentry-native/</SentryNativeRoot>
    <SentryLinuxArtifactsDestination>$(SentryArtifactsDestination)Linux/Sentry/</SentryLinuxArtifactsDestination>
    <SentryWindowsArtifactsDestination>$(SentryArtifactsDestination)Windows/Sentry/</SentryWindowsArtifactsDestination>
  </PropertyGroup>

  <!-- Use the Unity Editor version set in the sample project of the repo -->
  <Target Name="FindUnity">
    <Message Text="Unity Version: $(UnityVersion)" Importance="Normal" />

    <!-- Unity paths on Windows -->
    <PropertyGroup Condition="$([MSBuild]::IsOSPlatform('Windows'))">
      <UnityRoot Condition="Exists('C:\Program Files\Unity\Hub\Editor\$(UnityVersion)\Editor\Data\Managed\UnityEngine.dll')">C:\Program Files\Unity\Hub\Editor\$(UnityVersion)\Editor\</UnityRoot>
      <!--If not using Unity Hub, tries to pick whatever Unity version is installed on the machine-->
      <UnityRoot Condition="$(UnityRoot) == '' AND Exists('C:\Program Files\Unity\Editor\Data\Managed\UnityEngine.dll')">C:\Program Files\Unity\Editor</UnityRoot>
      <UnityLibcache>$(UnityRoot)Data/Resources/PackageManager/ProjectTemplates/libcache/</UnityLibcache>
      <UnityManagedPath>$(UnityRoot)\Data\Managed</UnityManagedPath>
      <UnityExec>&quot;$(UnityRoot)\Unity.exe&quot;</UnityExec>
      <StandaloneBuildMethod>Builder.BuildWindowsIl2CPPPlayer</StandaloneBuildMethod>
      <StandaloneBuildPath>$(PlayerBuildPath)Windows/IL2CPP_Player.exe</StandaloneBuildPath>
      <StandaloneExecutablePath>$(StandaloneBuildPath)</StandaloneExecutablePath>
      <StandaloneDataPath>$(USERPROFILE)/AppData/LocalLow/DefaultCompany/unity-of-bugs/</StandaloneDataPath>
    </PropertyGroup>

    <Error Condition="!Exists('$(UnityRoot)') AND $([MSBuild]::IsOSPlatform('Windows'))" Text="UnityRoot not found. Ensure Unity is installed.
See the CONTRIBUTING.md.
UnityVersion: '$(UnityVersion)'
Resolved directory: '$(UnityRoot)'
Expected to exist:
 * C:\Program Files\Unity\Hub\Editor\$(UnityVersion)\Editor\Data\Managed\UnityEngine.dll
or
 * C:\Program Files\Unity\Editor\Data\Managed\UnityEngine.dll" />

    <!-- Unity paths on macOS -->
    <PropertyGroup Condition="$([MSBuild]::IsOSPlatform('OSX'))">
      <UnityRoot Condition="Exists('/Applications/Unity/Hub/Editor/$(UnityVersion)/Unity.app/Contents/Managed/UnityEngine.dll')">/Applications/Unity/Hub/Editor/$(UnityVersion)/Unity.app/</UnityRoot>
      <!--If not using Unity Hub, tries to pick whatever Unity version is installed on the machine-->
      <UnityRoot Condition="$(UnityRoot) == '' AND Exists('/Applications/Unity/Unity.app/Contents/Managed/UnityEngine.dll')">/Applications/Unity/Unity.app/</UnityRoot>
      <UnityLibcache>$(UnityRoot)Contents/Resources/PackageManager/ProjectTemplates/libcache/</UnityLibcache>
      <UnityManagedPath>$(UnityRoot)Contents/Managed</UnityManagedPath>
      <UnityExec>&quot;$(UnityRoot)Contents/MacOS/Unity&quot;</UnityExec>
      <StandaloneBuildMethod>Builder.BuildMacIl2CPPPlayer</StandaloneBuildMethod>
      <StandaloneBuildPath>$(PlayerBuildPath)MacOS/IL2CPP_Player.app</StandaloneBuildPath>
      <StandaloneExecutablePath>$(StandaloneBuildPath)/Contents/MacOS/unity-of-bugs</StandaloneExecutablePath>
    </PropertyGroup>

    <Error Condition="!Exists('$(UnityRoot)') AND $([MSBuild]::IsOSPlatform('OSX'))" Text="UnityRoot not found. Ensure Unity is installed.
See the CONTRIBUTING.md.
UnityVersion: '$(UnityVersion)'
Resolved directory: '$(UnityRoot)'
Expected to exist:
 * /Applications/Unity/Hub/Editor/$(UnityVersion)/Unity.app/Contents/Managed/UnityEngine.dll
or
 * /Applications/Unity/Unity.app/Contents/Managed/UnityEngine.dll" />

    <!-- Unity paths on Linux -->
    <PropertyGroup Condition="$([MSBuild]::IsOSPlatform('Linux'))">
      <UnityRoot Condition="Exists('$(Home)/Unity/Hub/Editor/$(UnityVersion)/Editor/Data/Managed/UnityEngine.dll')">$(Home)/Unity/Hub/Editor/$(UnityVersion)/Editor/</UnityRoot>
      <UnityRoot Condition="$(UNITY_PATH) != ''">$(UNITY_PATH)/Editor/</UnityRoot>
      <UnityLibcache>$(UnityRoot)Data/Resources/PackageManager/ProjectTemplates/libcache/</UnityLibcache>
      <UnityManagedPath>$(UnityRoot)Data/Managed</UnityManagedPath>
      <UnityExec>xvfb-run -ae /dev/stdout &quot;$(UnityRoot)Unity&quot;</UnityExec>
      <StandaloneBuildMethod>Builder.BuildLinuxIl2CPPPlayer</StandaloneBuildMethod>
      <StandaloneBuildPath>$(PlayerBuildPath)Linux/IL2CPP_Player</StandaloneBuildPath>
      <StandaloneExecutablePath>$(StandaloneBuildPath)</StandaloneExecutablePath>
    </PropertyGroup>

    <Error Condition="!Exists('$(UnityRoot)') AND $([MSBuild]::IsOSPlatform('Linux'))" Text="UnityRoot not found. Ensure Unity is installed.
See the CONTRIBUTING.md.
UnityVersion: '$(UnityVersion)'
Resolved directory: '$(UnityRoot)'
Expected to exist:
 * $(Home)/Unity/Hub/Editor/$(UnityVersion)/Editor/Data/Managed/UnityEngine.dll" />

    <LocateTestRunner UnityLibcache="$(UnityLibcache)">
      <Output PropertyName="TestRunnerPath" TaskParameter="TestRunnerPath" />
    </LocateTestRunner>

    <PropertyGroup>
      <UnityTemplateAssemblyPath>$(TestRunnerPath)</UnityTemplateAssemblyPath>
    </PropertyGroup>

  </Target>

  <Target Name="CleanUnityTestResults" AfterTargets="Clean">
    <Delete Files="$(UnityTestPlayModeResultFilePath)" />
    <Delete Files="$(UnityTestEditModeResultFilePath)" />
    <RemoveDir Directories="$(PlayerBuildPath)" />
  </Target>

  <Target Name="CleaniOSSDK" AfterTargets="Clean" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <RemoveDir Directories="$(SentryCocoaRoot)Carthage" ContinueOnError="true" />
    <RemoveDir Directories="$(SentryiOSArtifactsDestination)" ContinueOnError="true" />
  </Target>

  <Target Name="CleanAndroidSDK" AfterTargets="Clean" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <!-- The jar file is version appended and we copy by glob so to avoid duplicates: -->
    <RemoveDir Directories="$(SentryAndroidRoot)sentry/build/libs/" ContinueOnError="true" />
    <RemoveDir Directories="$(SentryAndroidArtifactsDestination)" ContinueOnError="true" />
  </Target>

  <Target Name="CleanmacOSSDK" AfterTargets="Clean" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <RemoveDir Directories="$(SentryCocoaRoot)Carthage/Build/Mac" ContinueOnError="true" />
    <Delete Files="$(SentrymacOSArtifactsDestination)Sentry.dylib" ContinueOnError="true" />
    <Delete Files="$(SentrymacOSArtifactsDestination)Sentry.dylib.dSYM" ContinueOnError="true" />
  </Target>

  <Target Name="CleanLinuxSDK" AfterTargets="Clean" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <RemoveDir Directories="$(SentryNativeRoot)build/" ContinueOnError="true" />
    <Delete Files="$(SentryLinuxArtifactsDestination)libsentry.so" ContinueOnError="true" />
    <Delete Files="$(SentryLinuxArtifactsDestination)libsentry.dbg.so" ContinueOnError="true" />
  </Target>

  <Target Name="CleanWindowsSDK" AfterTargets="Clean" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <RemoveDir Directories="$(SentryNativeRoot)build/" ContinueOnError="true" />
    <Delete Files="$(SentryWindowsArtifactsDestination)crashpad_handler.exe" ContinueOnError="true" />
    <Delete Files="$(SentryWindowsArtifactsDestination)sentry.dll" ContinueOnError="true" />
    <Delete Files="$(SentryWindowsArtifactsDestination)sentry.pdb" ContinueOnError="true" />
  </Target>

  <Target Name="DownloadCLI" BeforeTargets="BeforeBuild" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity' AND !Exists('$(RepoRoot)package-dev/Editor/sentry-cli')">
    <Exec Command="pwsh &quot;$(RepoRoot)scripts/download-sentry-cli.ps1&quot;"></Exec>
  </Target>

  <!-- Build the iOS SDK: dotnet msbuild /t:BuildiOSSDK src/Sentry.Unity -->
  <Target Name="BuildiOSSDK" Condition="$([MSBuild]::IsOSPlatform('OSX'))
          And '$(MSBuildProjectName)' == 'Sentry.Unity'
          And (!Exists('$(SentryiOSArtifactsDestination)'))" BeforeTargets="BeforeBuild">
    <Error Condition="!Exists('$(SentryCocoaRoot)')" Text="Couldn't find the Cocoa root at $(SentryCocoaRoot)."></Error>
    <Message Importance="High" Text="Building Sentry iOS SDK."></Message>

    <!--    Workaround to enable building the Cocoa SDK with Bitcode enabled -->
    <Message Importance="High" Text="Creating xcconfig file to enable Bitcode." />
    <WriteLinesToFile File="$(SentryCocoaRoot)unity.xcconfig" Lines="ENABLE_BITCODE = YES" Overwrite="true" />

    <Exec WorkingDirectory="$(SentryCocoaRoot)" Command="carthage build --use-xcframeworks --no-skip-current --platform iOS" EnvironmentVariables="XCODE_XCCONFIG_FILE=unity.xcconfig" />

    <!-- Itemgroup for the output Sentry.framework so we have access to '%(RecursiveDir)' when copying -->
    <ItemGroup>
      <iOSDeviceBuildPath Include="$(SentryCocoaRoot)Carthage/Build/Sentry.xcframework/**/*" />
    </ItemGroup>
    <Copy SourceFiles="@(iOSDeviceBuildPath)" DestinationFiles="@(iOSDeviceBuildPath->'$(SentryiOSArtifactsDestination)%(RecursiveDir)%(Filename)%(Extension)')">
    </Copy>

    <Message Importance="High" Text="Deleting xcconfig file." />
    <Delete Files="$(SentryCocoaRoot)unity.xcconfig" />

    <Error Condition="(!Exists('$(SentryiOSArtifactsDestination)'))" Text="Failed to build the iOS SDK." />
  </Target>

  <!-- Build the macOS SDK: dotnet msbuild /t:BuildmacOSSDK src/Sentry.Unity -->
  <Target Name="BuildmacOSSDK" BeforeTargets="BeforeBuild" Condition="$([MSBuild]::IsOSPlatform('OSX'))
          And '$(MSBuildProjectName)' == 'Sentry.Unity'
          And (!Exists('$(SentrymacOSArtifactsDestination)Sentry.dylib') Or !Exists('$(SentrymacOSArtifactsDestination)Sentry.dylib.dSYM'))">
    <Error Condition="!Exists('$(SentryCocoaRoot)')" Text="Couldn't find the Cocoa root at $(SentryCocoaRoot)."></Error>
    <Message Importance="High" Text="Building Sentry macOS SDK."></Message>

    <Exec WorkingDirectory="$(SentryCocoaRoot)" Command="carthage build --no-skip-current --platform macOS"></Exec>

    <Copy SourceFiles="$(SentryCocoaRoot)Carthage/Build/Mac/Sentry.framework/Sentry" DestinationFiles="$(SentrymacOSArtifactsDestination)Sentry.dylib" />
    <Copy SourceFiles="$(SentryCocoaRoot)Carthage/Build/Mac/Sentry.framework.dSYM/Contents/Resources/DWARF/Sentry" DestinationFiles="$(SentrymacOSArtifactsDestination)Sentry.dylib.dSYM" />
  </Target>

  <!-- Build the Android SDK: dotnet msbuild /t:BuildAndroidSDK src/Sentry.Unity -->
  <Target Name="BuildAndroidSDK" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'
          And !Exists('$(SentryAndroidArtifactsDestination)')" BeforeTargets="BeforeBuild">
    <Error Condition="!Exists('$(SentryAndroidRoot)')" Text="Couldn't find the Android root at $(SentryAndroidRoot)."></Error>
    <Message Importance="High" Text="Building Sentry Android SDK."></Message>

    <Exec WorkingDirectory="$(SentryAndroidRoot)" EnvironmentVariables="JAVA_HOME=$(JAVA_HOME_17_X64)" Command="./gradlew -PsentryAndroidSdkName=sentry.native.android.unity :sentry-android-core:assembleRelease :sentry-android-ndk:assembleRelease :sentry:jar --no-daemon --stacktrace --warning-mode none"></Exec>

    <ItemGroup>
      <AndroidSdkArtifacts Include="$(SentryAndroidRoot)sentry-android-ndk/build/outputs/aar/sentry-android-ndk-release.aar" />
      <AndroidSdkArtifacts Include="$(SentryAndroidRoot)sentry-android-core/build/outputs/aar/sentry-android-core-release.aar" />
    </ItemGroup>

    <Copy SourceFiles="@(AndroidSdkArtifacts)" DestinationFiles="@(AndroidSdkArtifacts->'$(SentryAndroidArtifactsDestination)%(RecursiveDir)%(Filename)%(Extension)')" />
    <Exec WorkingDirectory="$(SentryAndroidRoot)" Command="cp sentry/build/libs/sentry*.jar $(SentryAndroidArtifactsDestination)sentry.jar" />

    <Error Condition="!Exists('$(SentryAndroidArtifactsDestination)')" Text="Failed to build the Android SDK."></Error>
  </Target>

  <!-- Build the Sentry Native SDK for Windows: dotnet msbuild /t:BuildWindowsSDK src/Sentry.Unity -->
  <Target Name="BuildWindowsSDK" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'
          And $([MSBuild]::IsOsPlatform('Windows'))
          And !Exists('$(SentryWindowsArtifactsDestination)sentry.dll')" BeforeTargets="BeforeBuild">
    <Error Condition="!Exists('$(SentryNativeRoot)')" Text="Couldn't find the Native root at $(SentryNativeRoot)."></Error>

    <Message Importance="High" Text="Building artifacts of Sentry Native SDK for Windows." />

    <Exec WorkingDirectory="$(SentryNativeRoot)" Command="cmake -B build -D SENTRY_BACKEND=crashpad -D SENTRY_SDK_NAME=sentry.native.unity -S ."></Exec>
    <Exec WorkingDirectory="$(SentryNativeRoot)" Command="cmake --build build --target sentry --config RelWithDebInfo --parallel"></Exec>
    <Exec WorkingDirectory="$(SentryNativeRoot)" Command="cmake --build build --target crashpad_handler --config Release --parallel"></Exec>

    <ItemGroup>
      <NativeSdkArtifacts Include="$(SentryNativeRoot)build/crashpad_build/handler/Release/crashpad_handler.exe" />
      <NativeSdkArtifacts Include="$(SentryNativeRoot)build/RelWithDebInfo/sentry.dll" />
      <NativeSdkArtifacts Include="$(SentryNativeRoot)build/RelWithDebInfo/sentry.pdb" />
    </ItemGroup>

    <Copy SourceFiles="@(NativeSdkArtifacts)" DestinationFiles="@(NativeSdkArtifacts->'$(SentryWindowsArtifactsDestination)%(Filename)%(Extension)')" />
  </Target>

  <!-- Build the Sentry Native SDK for Linux: dotnet msbuild /t:BuildLinuxSDK src/Sentry.Unity -->
  <Target Name="BuildLinuxSDK" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'
          And $([MSBuild]::IsOsPlatform('Linux'))
          And !Exists('$(SentryLinuxArtifactsDestination)libsentry.so')" BeforeTargets="BeforeBuild">
    <Error Condition="!Exists('$(SentryNativeRoot)')" Text="Couldn't find the Native root at $(SentryNativeRoot)."></Error>

    <Message Importance="High" Text="Building artifacts of Sentry Native SDK for Linux." />

    <Exec WorkingDirectory="$(SentryNativeRoot)" Command="cmake -B build -D SENTRY_BACKEND=breakpad -D SENTRY_SDK_NAME=sentry.native.unity -D CMAKE_BUILD_TYPE=RelWithDebInfo -S ." />
    <Exec WorkingDirectory="$(SentryNativeRoot)" Command="cmake --build build --target sentry --parallel" />

    <MakeDir Directories="$(SentryLinuxArtifactsDestination)"/>

    <!-- strip all, including exported symbols except those starting with 'sentry_', except for 'sentry__' -->
    <Exec WorkingDirectory="$(SentryNativeRoot)" Command="strip -s build/libsentry.so -w -K sentry_[^_]* -o $(SentryLinuxArtifactsDestination)libsentry.so" />
    <Exec WorkingDirectory="$(SentryNativeRoot)" Command="cp build/libsentry.so $(SentryLinuxArtifactsDestination)libsentry.dbg.so" />
    <Exec WorkingDirectory="$(SentryLinuxArtifactsDestination)" Command="objcopy --add-gnu-debuglink=libsentry.dbg.so libsentry.so" />
  </Target>

  <!-- Even with a successful build, Unity will error on 'usbmuxd' or log out to std-error which breaks msbuild.
We need to run a unity build to restore the test packages and for that reason we'll ignore errors here and assume a later step will validate the build is actually working:
  The offending error:
  [usbmuxd] Stop listen thread
  [usbmuxd] Error:
  [usbmuxd] Listen thread exitingit -batchmode -nographics -logFile - -projectPath $(UnitySampleProjectPath) -$(StandalonePlayerName) $(ArtifactName)
For that reason, Exec tasks to unity all ignore error. That means that subsequent tasks must exist to validate the command (i.e: parse logs, etc).
Related: https://forum.unity.com/threads/6572-debugger-agent-unable-to-listen-on-27.500387/  -->

  <!-- Setup Sentry options on Unity UI: dotnet msbuild /t:UnityConfigureSentryOptions src/Sentry.Unity -->
  <Target Name="UnityConfigureSentryOptions" DependsOnTargets="FindUnity" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <Error Condition="$(UnityExec) == ''" Text="Couldn't find Unity." />

    <Message Importance="High" Text="Configuring Sentry options."></Message>

    <Exec Command="pwsh &quot;$(RepoRoot)scripts/unity.ps1&quot; $(UnityExec) -quit -batchmode -nographics -projectPath $(UnitySampleProjectPath) -executeMethod Sentry.Unity.Editor.ConfigurationWindow.SentryEditorWindowInstrumentation.ConfigureOptions -sentryOptions.Dsn $(TestDsn)" IgnoreStandardErrorWarningFormat="true">
      <Output TaskParameter="ExitCode" PropertyName="UnityConfigureSentryOptionsExitCode"/>
    </Exec>

    <!-- Unity will return -1 or 0 on success. 1 Otherwise. -->
    <Error Text="Sentry options setup failed with code $(UnityConfigureSentryOptionsExitCode)" Condition=" '$(UnityConfigureSentryOptionsExitCode)' != '0' AND '$(BuildExitCode)' != '-1'"/>
  </Target>

  <!-- Build a player with IL2CPP: dotnet msbuild /t:UnityBuildStandalonePlayerIL2CPP src/Sentry.Unity -->
  <Target Name="UnityBuildStandalonePlayerIL2CPP" DependsOnTargets="FindUnity" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <Error Condition="$(UnityExec) == ''" Text="Couldn't find Unity." />
    <Error Condition="$(StandaloneBuildMethod) == ''" Text="StandaloneBuildMethod build variable not defined. Did FindUnity target fail?"></Error>

    <Message Importance="High" Text="Building Player with IL2CPP."></Message>

    <Exec Command="pwsh &quot;$(RepoRoot)scripts/unity.ps1&quot; $(UnityExec) -quit -batchmode -nographics -projectPath $(UnitySampleProjectPath) -executeMethod $(StandaloneBuildMethod) -buildPath $(StandaloneBuildPath)" IgnoreStandardErrorWarningFormat="true"></Exec>
  </Target>

  <!-- Run smoke test on player: dotnet msbuild /t:UnitySmokeTestStandalonePlayerIL2CPP src/Sentry.Unity -->
  <Target Name="UnitySmokeTestStandalonePlayerIL2CPP" DependsOnTargets="FindUnity" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <Error Condition="$(UnityExec) == ''" Text="Couldn't find Unity." />

    <Exec Command="pwsh &quot;$(RepoRoot)test/Scripts.Integration.Test/integration-run-smoke-test.ps1&quot; -Smoke -Crash &quot;$(StandaloneExecutablePath)&quot; -AppDataDir &quot;$(StandaloneDataPath)&quot;" />
  </Target>

  <!-- Build an Android player: dotnet msbuild /t:UnityBuildPlayerAndroid src/Sentry.Unity -->
  <Target Name="UnityBuildPlayerAndroid" DependsOnTargets="FindUnity" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <Error Condition="$(UnityExec) == ''" Text="Couldn't find Unity." />

    <Message Importance="High" Text="Building Android Player with IL2CPP."></Message>

    <Exec Command="pwsh &quot;$(RepoRoot)scripts/unity.ps1&quot; $(UnityExec) -quit -batchmode -nographics -projectPath $(UnitySampleProjectPath) -executeMethod $(AndroidBuildMethod) -buildPath $(AndroidBuildPath)" IgnoreStandardErrorWarningFormat="true"></Exec>

    <Error Condition="!Exists('$(AndroidBuildPath)')" Text="Android APK not found. Did something go wrong?"></Error>
  </Target>

  <!-- Build an iOS player: dotnet msbuild /t:UnityBuildPlayerIOS src/Sentry.Unity -->
  <Target Name="UnityBuildPlayerIOS" DependsOnTargets="FindUnity" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <Error Condition="$(UnityExec) == ''" Text="Couldn't find Unity." />

    <Message Importance="High" Text="Building iOS Xcode project."></Message>

    <Exec Command="pwsh &quot;$(RepoRoot)scripts/unity.ps1&quot; $(UnityExec) -quit -batchmode -nographics -projectPath $(UnitySampleProjectPath) -executeMethod $(IOSBuildMethod) -buildPath $(IOSBuildPath)" IgnoreStandardErrorWarningFormat="true"></Exec>

    <!-- <Error Condition="!Exists('$(IOSBuildPath)')" Text="iOS build not found. Did something go wrong?"></Error> -->
  </Target>

  <!-- Build a WebGL player: dotnet msbuild /t:UnityBuildPlayerWebGL src/Sentry.Unity -->
  <Target Name="UnityBuildPlayerWebGL" DependsOnTargets="FindUnity" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <Error Condition="$(UnityExec) == ''" Text="Couldn't find Unity." />

    <Message Importance="High" Text="Building the sample player for WebGL." />

    <Exec Command="pwsh &quot;$(RepoRoot)scripts/unity.ps1&quot; $(UnityExec) -quit -batchmode -nographics -projectPath $(UnitySampleProjectPath) -executeMethod Builder.BuildWebGLPlayer -buildPath $(PlayerBuildPath)WebGL" IgnoreStandardErrorWarningFormat="true" />
  </Target>

  <!-- Run smoke test on the WebGL player: dotnet msbuild /t:UnitySmokeTestPlayerWebGL src/Sentry.Unity -->
  <Target Name="UnitySmokeTestPlayerWebGL" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <Exec Command="python3 -X utf8 &quot;$(RepoRoot)scripts/smoke-test-webgl.py&quot;" IgnoreStandardErrorWarningFormat="true"/>
  </Target>

  <!-- Run PlayMode tests with dotnet msbuild /t:UnityPlayModeTest test/Sentry.Unity.Tests -->
  <Target Name="UnityPlayModeTest" DependsOnTargets="FindUnity" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity.Tests'">
    <Error Condition="$(UnityExec) == ''" Text="Couldn't find Unity." />

    <Message Importance="High" Text="Running Unity PlayMode tests." />

    <!-- Unity exits with a non-zero exit code when running tests. We ignore it and manually check the test results instead. -->
    <Delete Files="$(UnityTestPlayModeResultFilePath)" />
    <Exec EnvironmentVariables="IgnoreExitCode=true" Command="pwsh &quot;$(RepoRoot)scripts/unity.ps1&quot; $(UnityExec) -batchmode -nographics -runTests -testPlatform PlayMode -projectPath $(UnitySampleProjectPath) -testResults $(UnityTestPlayModeResultFilePath)" />
    <UnityTestResults Path="$(UnityTestPlayModeResultFilePath)" />
  </Target>

  <!-- Run EditMode tests with dotnet msbuild /t:UnityEditModeTest test/Sentry.Unity.Editor.Tests -->
  <Target Name="UnityEditModeTest" DependsOnTargets="FindUnity" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity.Editor.Tests'">
    <Error Condition="$(UnityExec) == ''" Text="Couldn't find Unity." />

    <Message Importance="High" Text="Running Unity EditMode tests." />

    <!-- Unity exits with a non-zero exit code when running tests. We ignore it and manually check the test results instead. -->
    <!-- IgnoreStandardErrorWarningFormat="true" because of the intentional compilation error printed in GenerateOptions_NewSentryOptionsGarbageAppended_FailsToCompile(). -->
    <Delete Files="$(UnityTestEditModeResultFilePath)" />
    <Exec EnvironmentVariables="IgnoreExitCode=true" IgnoreStandardErrorWarningFormat="true" Command="pwsh &quot;$(RepoRoot)scripts/unity.ps1&quot; $(UnityExec) -batchmode -nographics -runTests -testPlatform EditMode -projectPath $(UnitySampleProjectPath) -testResults $(UnityTestEditModeResultFilePath)"/>
    <UnityTestResults Path="$(UnityTestEditModeResultFilePath)" />
  </Target>

  <!-- Locate the TestRunner.dlls by filling the wildcard with the template version number. 3d is the default template -->
  <UsingTask TaskName="LocateTestRunner" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <UnityLibcache ParameterType="System.String" Required="true" />
      <TestRunnerPath ParameterType="System.String" Output="true" />
    </ParameterGroup>

    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Linq" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
var directories = Directory.GetDirectories(UnityLibcache, "com.unity.template.3d-*");
if (directories.Length == 1)
{
    TestRunnerPath = Path.Combine(directories[0], "ScriptAssemblies");
    Log.LogMessage("Found TestRunner path at: " + TestRunnerPath);
    return true;
}

Log.LogError("Failed to resolve 'com.unity.template.3d-*' for TestRunner at: " + UnityLibcache);
]]>
      </Code>
    </Task>
  </UsingTask>

  <!-- Exclude package from manifest -->
  <UsingTask TaskName="ExcludePackage" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <PackageManifestFile ParameterType="System.String" Required="true" />
      <PackageToRemove ParameterType="System.String" Required="true" />
    </ParameterGroup>

    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Linq" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
if (!File.Exists(PackageManifestFile))
{
    Log.LogError("No manifest file at " + PackageManifestFile);
    return false;
}
var lines = File.ReadLines(PackageManifestFile).Where(l => !l.Contains($"\"{PackageToRemove}\"")).ToArray();
File.WriteAllLines(PackageManifestFile, lines);
]]>
      </Code>
    </Task>
  </UsingTask>

  <!-- Parse test results -->
  <UsingTask TaskName="UnityTestResults" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Path ParameterType="System.String" Required="true" />
    </ParameterGroup>

    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Linq" />
      <Using Namespace="System.Xml.Linq" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[

if (!File.Exists(Path))
{
    Log.LogError("Test results file not found at " + Path);
    return false;
}

var document = XDocument.Load(Path);
var testRun = document.Descendants("test-run").First();

var total = testRun.Attribute("total").Value;
if (total == "0")
{
    Log.LogError("Unity test results is empty.");
    return false;
}

var result = testRun.Attribute("result").Value;

Log.LogCriticalMessage("UnityTestResults", null, null, null, 0, 0, 0, 0, "{0} in {1}s", result.Replace("(Child)", ""), testRun.Attribute("duration").Value);
Log.LogCriticalMessage("UnityTestResults", null, null, null, 0, 0, 0, 0, "        Passed: {0,3}", testRun.Attribute("passed").Value);
Log.LogCriticalMessage("UnityTestResults", null, null, null, 0, 0, 0, 0, "        Failed: {0,3}", testRun.Attribute("failed").Value);
Log.LogCriticalMessage("UnityTestResults", null, null, null, 0, 0, 0, 0, "       Skipped: {0,3}", testRun.Attribute("skipped").Value);
Log.LogCriticalMessage("UnityTestResults", null, null, null, 0, 0, 0, 0, "  Inconclusive: {0,3}", testRun.Attribute("inconclusive").Value);

if (result == "Passed")
{
    return true;
}

PrintFailedTests(testRun);

var failed = testRun.Attribute("failed").Value;
var errorMessage = $"Test run completed with {failed} failing test{(int.Parse(failed) > 1 ? "s" : "")}.";
Log.LogError(errorMessage);

Success = false;

void PrintFailedTests(XElement element)
{
    foreach (var descendant in element.Descendants())
    {
        if (descendant.Name != "test-case"
            || descendant.Attribute("result")?.Value != "Failed")
        {
            continue;
        }

        if (descendant.Descendants().Any(d => d.Name == "test-case"))
        {
            PrintFailedTests(descendant);
        }
        else
        {
            var sb = new StringBuilder()
              .Append("Test ")
              .Append(descendant.Attribute("id")?.Value)
              .Append(": ")
              .AppendLine(descendant.Attribute("name")?.Value);

            var failure = descendant.Descendants("failure")
                .Descendants("message")
                .FirstOrDefault()
                ?.Value;

            var stack = descendant.Descendants("failure")
                .Descendants("stack-trace")
                .FirstOrDefault()
                ?.Value;

            sb.AppendLine(failure)
              .Append("Test StackTrace: ")
              .AppendLine(stack);

//  MSBuild is breaking each line as if it was an error per line and not a single error.
//  So Log.LogError got replaced by Console.WriteLine for now.
            Console.WriteLine(sb.ToString());
        }
    }
}
]]>
      </Code>
    </Task>
  </UsingTask>

  <!-- Checks if the environment variable 'SENTRY_AUTH_TOKEN' has been set and creates the SentryCliOptions.asset for the sample project
       This is meant for developers - so they don't have to configure the CLI options after each clean checkout (or git clean).
       Gets automatically run after 'DownloadNativeSDKs'
       dotnet msbuild /t:SetupSampleSentryCliOptions src/Sentry.Unity -->
  <Target Name="SetupSampleSentryCliOptions" AfterTargets="DownloadNativeSDKs" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity' AND '$(SENTRY_AUTH_TOKEN)' != ''">
    <Message Importance="High" Text="Found environment variable 'SENTRY_AUTH_TOKEN'. Creating Sentry CLI options for sample project. " />
    <Exec Command="pwsh &quot;$(RepoRoot)scripts/create-sentry-cli-options.ps1&quot;"/>
  </Target>

  <!--  Downloads native SDKs from the latest successful GitHub Actions workflow run.
        This is meant for developers - so that they don't have to compile the native SDK after each clean checkout (or git clean).
        Depends on your a GH CLI installation - https://cli.github.com/
        dotnet msbuild /t:DownloadNativeSDKs src/Sentry.Unity -->
  <Target Name="DownloadNativeSDKs" Condition="'$(MSBuildProjectName)' == 'Sentry.Unity'">
    <Message Importance="High" Text="Downloading pre-compiled native SDKs from GitHub Actions artifacts." />
    <Exec ConsoleToMSBuild="true" Command="gh run list --branch main --workflow CI --json &quot;conclusion,databaseId&quot; --jq &quot;first(.[] | select(.conclusion == \&quot;success\&quot;) | .databaseId)&quot;">
      <Output TaskParameter="ConsoleOutput" PropertyName="LastSuccessfulRunId" />
    </Exec>
    <Error Condition="!('$(LastSuccessfulRunId)' > 0)" Text="Failed to find a successful run" />

    <ItemGroup>
      <SDK Include="Windows"/>
      <SDK Include="iOS"/>
      <SDK Include="macOS"/>
      <SDK Include="Android"/>
      <SDK Include="Linux"/>
    </ItemGroup>
    <Message Importance="High" Text="Replacing $(SentryArtifactsDestination)%(SDK.Identity)" />
    <RemoveDir Directories="$(SentryArtifactsDestination)%(SDK.Identity)" />
    <Exec Command="gh run download $(LastSuccessfulRunId) -n &quot;%(SDK.Identity)-sdk&quot; -D &quot;$(SentryArtifactsDestination)%(SDK.Identity)&quot;" />

    <!-- Download overwrites some files that then show up as changed in the IDE, even though there are no changes, e.g. only whitespace -->
    <Message Importance="High" Text="Restoring package-dev/Plugins to the latest git commit" />
    <Exec WorkingDirectory="$(RepoRoot)" Command="git restore package-dev/Plugins" />


  </Target>
</Project>
